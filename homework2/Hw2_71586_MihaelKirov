#include<iostream>
#include<cassert>
#include<cmath>
using namespace std;
double P = 3.141592;

class Point
{
public:
    Point (int x = 1, int y = 1)
    {
        this->x = x;
        this->y = y;
    }
    Point (const Point& other)
    {
        x = other.x;
        y = other.y;
    }
    Point& operator = (const Point& other)
    {
        if (this != &other)
        {
            x = other.x;
            y = other.y;
        }
        return *this;
    }
    int getX () const
    {
        return x;
    }
    void setX (int x)
    {
        this->x = x;
    }
    int getY () const
    {
        return y;
    }
    void setY (int y)
    {
        this->y = y;
    }
    void print () const
    {
        cout << "x " << x << endl;
        cout << "y " << y << endl;
    }
    bool isEqual (const Point other)
    {
        return (x == other.x && y == other.y);
    }
private:
    int x;
    int y;
};

class Figure
{
public:
    virtual double getArea ()  = 0;
    virtual double getPerimeter ()  = 0;
    virtual Point getCentre () = 0;
    const virtual char* getType () = 0;
};

class Circle : public Figure
{
private:
    Point O;
    double r;
public:
    Circle (double r, Point O)
    {
        this->r = r;
        this->O = O;
    }
    ~Circle()
    {

    }
    Circle (const Circle& other)
    {
        O = other.O;
        r = other.r;
    }
    Circle& operator = (const Circle& other)
    {
        if (this != &other)
        {
            O = other.O;
            r = other.r;
        }
        return *this;
    }
    virtual double getArea ()
    {
        return P*(pow (r, 2));
    }
    virtual double getPerimeter ()
    {
        return 2*P*r;
    }
    Point getCentre ()
    {
        return O;
    }
    const char* getType ()
    {
        return "circle";
    }
    bool operator == (const Circle& other)
    {
        return (this->r == other.r && O.isEqual(other.O));
    }
    double getR () const
    {
        return r;
    }
    double getOx() const
    {
        return O.getX();
    }
    double getOy() const
    {
        return O.getY();
    }

};

class Triangle : public Figure
{
private:
    Point points[3];
public:
    Triangle (Point a, Point b, Point c)
    {
        points[0] = a;
        points[1] = b;
        points[2] = c;
    }
    ~Triangle()
    {

    }
    Triangle (const Triangle& other)
    {
        points[0] = other.points[0];
        points[1] = other.points[1];
        points[2] = other.points[2];
    }
    Triangle& operator = (const Triangle& other)
    {
        if (this != &other)
        {
            points[0] = other.points[0];
            points[1] = other.points[1];
            points[2] = other.points[2];
        }
        return *this;
    }
    virtual double getArea ()
    {
        
    }
    virtual double getPerimeter ()
    {
        return getAB() + getCA() + getCB();
    }
    const char* getType ()
    {
        return "triangle";
    }
    Point getCentre ()
    {
        double Ox = (points[0].getX() + points[1].getX() + points[2].getX()) / 3;
        double Oy = (points[0].getY() + points[1].getY() + points[2].getY()) / 3;
        return Point(Ox, Oy);
    }
    double getCenterOx ()
    {
        return (points[0].getX() + points[1].getX() + points[2].getX()) / 3;
    }
    double getCenterOy ()
    {
        return (points[0].getY() + points[1].getY() + points[2].getY()) / 3;
    }
    bool operator == (const Triangle& other)
    {
        return (points[0].isEqual(other.points[0]) && points[1].isEqual(other.points[1]) && points[2].isEqual(other.points[2]));
    }
    double getAB () const
    {
        double x = points[1].getX() - points[0].getX();
        double y = points[1].getY() - points[0].getY();
        return sqrt ((pow(x, 2)) + pow(y, 2));
    }
    double getCB () const
    {
        double x = points[2].getX() - points[1].getX();
        double y = points[2].getY() - points[1].getY();
        return sqrt ((pow(x, 2)) + pow(y, 2));
    }
    double getCA () const
    {
        double x = points[2].getX() - points[0].getX();
        double y = points[2].getY() - points[0].getY();
        return sqrt ((pow(x, 2)) + pow(y, 2));
    }
    double getX (Point p)
    {
        return p.getX();
    }
    double getY (Point p)
    {
        return p.getY();
    }
    double getR () const
    {
       
    }

};

class Rectangle : public Figure
{
private:
    Point points[2];
public:
    Rectangle (Point a, Point b)
    {
        this->points[0] = a;
        this->points[1] = b;
    }
    ~Rectangle()
    {

    }
    Rectangle (const Rectangle& other)
    {
        points[0] = other.points[0];
        points[1] = other.points[1];
    }
    Rectangle& operator = (const Rectangle& other)
    {
        if (this != &other)
        {
            points[0] = other.points[0];
            points[1] = other.points[1];
        }
        return *this;
    }
    double getA()
    {
        return abs((points[1].getY() - points[0].getY()));
    }
    double getB ()
    {
        return abs((points[0].getX() - points[1].getX()));
    }
    double getArea ()
    {
        return (getA() * getB());
    }
    double getPerimeter ()
    {
        return 2 * (getA() + getB());
    }
    Point getCentre ()
    {
        double Ox = (points[1].getX() - points[0].getX()) / 2;
        double Oy = (points[1].getY() - points[0].getY()) / 2;
        return Point(Ox, Oy);
    }
    double getCentreOx ()
    {
        return (points[1].getX() - points[0].getX()) / 2;
    }
    double getCentreOy ()
    {
        return (points[1].getY() - points[0].getY()) / 2;
    }
    const char* getType ()
    {
        return "rectangle";
    }
    bool operator == (const Rectangle& other)
    {
        return (points[0].isEqual(other.points[0]) && points[1].isEqual(other.points[1]));
    }
    double getR ()
    {
        return getA()/2;
    }

};


int main ()
{

}
